# -*- coding: utf-8 -*-
"""MLZoomcamp_HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tv6nXGemZkCfQrDwXk6CMkJEP9DWPbZk
"""

import pandas as pd
import numpy as np
 
import seaborn as sns
from matplotlib import pyplot as plt

"""Get The Data: New York City Airbnb Open Data"""

!wget https://raw.githubusercontent.com/alexeygrigorev/datasets/master/AB_NYC_2019.csv

df = pd.read_csv('AB_NYC_2019.csv')
len(df)

df.head()

used_columns = [
                'latitude',
                'longitude',
                'price',
                'minimum_nights',
                'number_of_reviews',
                'reviews_per_month',
                'calculated_host_listings_count',
                'availability_365'   
                ]

HW_df = df[used_columns]
HW_df.head(3)

"""------------------------------------------------------------------------------
ANS Q1:
"""

HW_df.isnull().sum()

"""------------------------------------------------------------------------------
ANS Q2:
"""

HW_df['minimum_nights'].median()

"""------------------------------------------------------------------------------
Split Data (Manually)
"""

def split_data(n,split_val,split_test):
  n_val = int(split_val*n)
  n_test = int(split_test*n)
  n_train = n - n_val - n_test
  print('Train Split : ', 1 - split_val - split_test)
  print(' ')
  print(n_train, n_val, n_test)
  
  return n_train, n_val, n_test

n = len(HW_df)

split_val = float(input('Val Split : '))
split_test = float(input('Test Split : '))

n_train, n_val, n_test = split_data(n,split_val,split_test)

idx = np.arange(n)

np.random.seed(42)
np.random.shuffle(idx)

df_train = HW_df.iloc[idx[:n_train]]
df_val = HW_df.iloc[idx[n_train:n_train+n_val]]
df_test = HW_df.iloc[idx[n_train+n_val:]]

df_train = df_train.reset_index(drop=True)
df_val = df_val.reset_index(drop=True)
df_test = df_test.reset_index(drop=True)

df_train.head(3)

y_train = np.log1p(df_train.price.values)
y_val = np.log1p(df_val.price.values)
y_test = np.log1p(df_test.price.values)

y_train

del df_train['price']
del df_val['price']
del df_test['price']

len(y_train)

df_train.head(3)

"""------------------------------------------------------------------------------
Linear Regression (w/o Regularization)
"""

def LG_wo_R(X, y):
  ones = np.ones(X.shape[0])
  X = np.column_stack([ones, X])

  XTX = X.T.dot(X)
  XTX_inv = np.linalg.inv(XTX)
  w = XTX_inv.dot(X.T).dot(y)

  return w[0], w[1:]

"""------------------------------------------------------------------------------
RMSE
"""

def RMSE(y, y_pred):
  e = y_pred - y
  mse = (e ** 2).mean()
  rmse_val = np.sqrt(mse)

  return rmse_val

"""------------------------------------------------------------------------------
ANS Q3:
For this question there are 2 options


1.   Fill the Missing Value with 0
2.   Fill the Missing Value with mean


"""

base = [
        'latitude',
        'longitude',
        'minimum_nights',
        'number_of_reviews',
        'reviews_per_month',
        'calculated_host_listings_count',
        'availability_365'
        ]

"""*Option 1*"""

def X_opt_1(df):
  df_opt_1 = df[base]
  df_opt_1 = df_opt_1.fillna(0)
  X = df_opt_1.values

  return X

X1_train = X_opt_1(df_train)
w0_1, w_1 = LG_wo_R(X1_train, y_train)

y1_pred = w0_1 + X1_train.dot(w_1)

print('RMSE value = ', round(RMSE(y_train, y1_pred), 2))

"""*Option 2*"""

def X_opt_2(df):
  df_opt_1 = df[base]
  df_opt_1 = df_opt_1.fillna(float(HW_df['reviews_per_month'].mean()))
  X = df_opt_1.values

  return X

X2_train = X_opt_2(df_train)
w0_2, w_2 = LG_wo_R(X2_train, y_train)

y2_pred = w0_2 + X2_train.dot(w_2)

print('RMSE value = ', round(RMSE(y_train, y2_pred), 2))

"""-------------------------------------------------------------------------------
Regulized Linear Regression
"""

def LG_w_R(X, y, r=0.0):
  ones = np.ones(X.shape[0])
  X = np.column_stack([ones, X])

  XTX = X.T.dot(X)
  reg = r * np.eye(XTX.shape[0])
  XTX += reg
  
  XTX_inv = np.linalg.inv(XTX)
  w = XTX_inv.dot(X.T).dot(y)

  return w[0], w[1:]

"""---------------------------------------------------------------------------------------------
ANS Q4:
"""

X_train_q4 = X_opt_1(df_train)
X_val_q4 = X_opt_1(df_val)

for r_q4 in [0, 0.000001, 0.0001, 0.001, 0.01, 0.1, 1, 5, 10]:
  w0_q4, w_q4 = LG_w_R(X_train_q4, y_train, r=r_q4)
  y_pred_q4 = w0_q4 + X_val_q4.dot(w_q4)
  print('r = %7s' %r_q4, '-> RMSE value = ', round(RMSE(y_val, y_pred_q4), 2))

"""------------------------------------------------------------------------------
ANS Q5:
"""

n_q5 = len(HW_df)

split_val_q5 = float(input('Val Split : '))
split_test_q5 = float(input('Test Split : '))

n_train_q5, n_val_q5, n_test_q5 = split_data(n_q5,split_val_q5,split_test_q5)

for s in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]:
  idx_q5 = np.arange(n)

  np.random.seed(s)
  np.random.shuffle(idx_q5)

  df_train_q5 = HW_df.iloc[idx_q5[:n_train_q5]]
  df_val_q5 = HW_df.iloc[idx_q5[n_train_q5:n_train_q5+n_val_q5]]
  df_test_q5 = HW_df.iloc[idx_q5[n_train_q5+n_val_q5:]]

  df_train_q5 = df_train_q5.reset_index(drop=True)
  df_val_q5 = df_val_q5.reset_index(drop=True)
  df_test_q5 = df_test_q5.reset_index(drop=True)

  y_train_q5 = np.log1p(df_train_q5.price.values)
  y_val_q5 = np.log1p(df_val_q5.price.values)
  y_test_q5 = np.log1p(df_test_q5.price.values)  

  del df_train_q5['price']
  del df_val_q5['price']
  del df_test_q5['price']

  X_train_q5 = X_opt_1(df_train_q5)
  X_val_q5 = X_opt_1(df_val_q5)
  
  w0_q5, w_q5 = LG_wo_R(X_train_q5, y_train_q5)
  y_pred_q5 = w0_q5 + X_val_q5.dot(w_q5)
  RMSE_score = round(RMSE(y_val, y_pred_q5), 4)

  print('s = %1s' %s, '-> RMSE value = ', RMSE_score)

scores = [0.7427, 0.7387, 0.7427, 0.7381, 0.7403, 0.7434, 0.7393, 0.7415, 0.7418, 0.7434]
scores = np.array(scores)

print('Standard  Deviation = ', round(np.std(scores), 3))

"""------------------------------------------------------------------------------
ANS Q6:
"""

n_q6 = len(HW_df)

split_val_q6 = float(input('Val Split : '))
split_test_q6 = float(input('Test Split : '))

n_train_q6, n_val_q6, n_test_q6 = split_data(n_q6,split_val_q6,split_test_q6)

idx_q6 = np.arange(n)

np.random.seed(9)
np.random.shuffle(idx_q6)

df_train_q6 = HW_df.iloc[idx_q5[:n_train_q6+n_val_q6]]
df_test_q6 = HW_df.iloc[idx_q5[n_train_q6+n_val_q6:]]

df_train_q6 = df_train_q6.reset_index(drop=True)
df_test_q6 = df_test_q6.reset_index(drop=True)

y_train_q6 = np.log1p(df_train_q6.price.values)
y_test_q6 = np.log1p(df_test_q6.price.values) 

del df_train_q6['price']
del df_test_q6['price']

X_train_q6 = X_opt_1(df_train_q6)
X_test_q6 = X_opt_1(df_test_q6)
  
w0_q6, w_q6 = LG_w_R(X_train_q6, y_train_q6, r=0.001)
y_pred_q6 = w0_q6 + X_test_q6.dot(w_q6)
RMSE_score = round(RMSE(y_test_q6, y_pred_q6), 2)

print('RMSE value = ', RMSE_score)